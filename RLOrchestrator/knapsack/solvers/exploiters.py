"""
Knapsack Exploiter Variants - Configured for CONVERGENCE and LOCAL REFINEMENT.

All exploiters are tuned to:
- Converge population toward best solutions
- Apply intensive local search (greedy bit flips)
- Refine solutions toward local optima
- Support binary knapsack representation with repair

Key tuning principles:
- Low randomness
- High selection pressure
- Strong attraction to best
- Greedy improvement moves
"""

from __future__ import annotations

from typing import List, Optional

import numpy as np

from Core.problem import ProblemInterface, Solution
from Core.search_algorithm import SearchAlgorithm


# =============================================================================
# Binary Utilities
# =============================================================================

class BinaryKnapsackMixin:
    """Provides binary operations for Knapsack solvers with repair."""
    
    def _repair(self, mask: np.ndarray) -> np.ndarray:
        """Repair mask to satisfy capacity constraint."""
        if hasattr(self.problem, 'repair_mask'):
            return np.asarray(self.problem.repair_mask(mask.tolist()), dtype=int)
        return mask
    
    def _bit_flip_mutation(self, mask: np.ndarray, rate: float) -> np.ndarray:
        """Flip bits with given probability."""
        flips = self.rng.random(len(mask)) < rate
        result = mask.copy()
        result[flips] = 1 - result[flips]
        return self._repair(result)
    
    def _uniform_crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:
        """Uniform crossover between two binary vectors."""
        mask_prob = self.rng.random(len(parent1)) < 0.5
        child = np.where(mask_prob, parent1, parent2)
        return self._repair(child)
    
    def _greedy_flip_search(self, mask: np.ndarray, max_iter: int = 20) -> tuple:
        """Greedy bit-flip local search."""
        current = mask.copy()
        sol = Solution(current.tolist(), self.problem)
        sol.evaluate()
        current_fit = sol.fitness
        
        improved = True
        iterations = 0
        
        while improved and iterations < max_iter:
            improved = False
            iterations += 1
            
            # Try random bit flips
            for _ in range(len(mask)):
                idx = self.rng.integers(len(mask))
                candidate = current.copy()
                candidate[idx] = 1 - candidate[idx]
                candidate = self._repair(candidate)
                
                cand_sol = Solution(candidate.tolist(), self.problem)
                cand_sol.evaluate()
                
                if cand_sol.fitness < current_fit:
                    current = candidate
                    current_fit = cand_sol.fitness
                    improved = True
                    break
        
        return current, current_fit


# =============================================================================
# Greedy Bit-Flip Exploiter
# =============================================================================

class KnapsackGreedyExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Intensive greedy bit-flip exploiter for Knapsack.
    
    Primary exploitation: apply greedy local search to elite solutions.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 elite_ratio: float = 0.4, local_search_iter: int = 30,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.elite_ratio = elite_ratio
        self.local_search_iter = local_search_iter
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        n_elite = max(1, int(self.population_size * self.elite_ratio))

        new_population = []

        # Apply local search to elite
        for idx in range(n_elite):
            mask = np.array(sorted_pop[idx].representation)
            improved_mask, improved_fit = self._greedy_flip_search(mask, self.local_search_iter)
            new_sol = Solution(improved_mask.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        # Fill rest from elite with small perturbations
        while len(new_population) < self.population_size:
            elite_idx = self.rng.integers(0, n_elite)
            mask = np.array(sorted_pop[elite_idx].representation)
            
            # Small perturbation
            idx = self.rng.integers(len(mask))
            mask[idx] = 1 - mask[idx]
            mask = self._repair(mask)
            
            # Light local search
            improved_mask, improved_fit = self._greedy_flip_search(mask, 5)
            new_sol = Solution(improved_mask.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# GA Exploiter
# =============================================================================

class KnapsackGAExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Genetic Algorithm for Knapsack EXPLOITATION.
    
    Strong elitism, low mutation, high selection pressure.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 mutation_rate: float = 0.05, elite_ratio: float = 0.3,
                 tournament_size: int = 5, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.mutation_rate = mutation_rate
        self.elite_ratio = elite_ratio
        self.tournament_size = tournament_size
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        n_elite = max(1, int(self.population_size * self.elite_ratio))

        new_population = []
        
        # Strong elitism
        for i in range(n_elite):
            new_population.append(sorted_pop[i].copy(preserve_id=False))

        while len(new_population) < self.population_size:
            parent1 = self._tournament_select()
            parent2 = self._tournament_select()
            
            mask = self._uniform_crossover(
                np.array(parent1.representation),
                np.array(parent2.representation)
            )
            
            # Light mutation
            if self.rng.random() < self.mutation_rate:
                idx = self.rng.integers(len(mask))
                mask[idx] = 1 - mask[idx]
                mask = self._repair(mask)

            sol = Solution(mask.tolist(), self.problem)
            sol.evaluate()
            new_population.append(sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1

    def _tournament_select(self) -> Solution:
        candidates = self.rng.choice(self.population, self.tournament_size, replace=False)
        return min(candidates, key=lambda s: s.fitness)


# =============================================================================
# PSO Exploiter
# =============================================================================

class KnapsackPSOExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Particle Swarm Optimization for Knapsack EXPLOITATION.
    
    High social, low cognitive for convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 cognitive: float = 0.3, social: float = 0.7,
                 local_search_iter: int = 10, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.cognitive = cognitive
        self.social = social
        self.local_search_iter = local_search_iter
        self._dim = None
        self.rng = np.random.default_rng(seed)
        self.pbest: List[Solution] = []
        self.gbest: Optional[Solution] = None

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
            for sol in self.population:
                if sol.fitness is None:
                    sol.evaluate()
            self.pbest = [sol.copy(preserve_id=False) for sol in self.population]
            self.gbest = min(self.pbest, key=lambda s: s.fitness)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        for i, sol in enumerate(self.population):
            mask = np.array(sol.representation)
            
            # Strong attraction to global best
            if self.rng.random() < self.social and self.gbest:
                mask = self._uniform_crossover(mask, np.array(self.gbest.representation))
            
            # Weaker attraction to personal best
            if self.rng.random() < self.cognitive:
                mask = self._uniform_crossover(mask, np.array(self.pbest[i].representation))
            
            # Apply local search
            mask, fitness = self._greedy_flip_search(mask, self.local_search_iter)

            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.fitness = fitness
            self.population[i] = new_sol

            if new_sol.fitness < self.pbest[i].fitness:
                self.pbest[i] = new_sol.copy(preserve_id=False)

        current_best = min(self.population, key=lambda s: s.fitness)
        if self.gbest is None or current_best.fitness < self.gbest.fitness:
            self.gbest = current_best.copy(preserve_id=False)

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# GWO Exploiter
# =============================================================================

class KnapsackGWOExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Grey Wolf Optimizer for Knapsack EXPLOITATION.
    
    Strong hierarchy, fast convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        alpha = sorted_pop[0] if len(sorted_pop) > 0 else None
        beta = sorted_pop[1] if len(sorted_pop) > 1 else alpha
        delta = sorted_pop[2] if len(sorted_pop) > 2 else beta

        new_population = []
        for sol in self.population:
            mask = np.array(sol.representation)
            
            # Strong encircling of alpha
            if alpha and self.rng.random() < 0.6:
                mask = self._uniform_crossover(mask, np.array(alpha.representation))
            elif beta and self.rng.random() < 0.3:
                mask = self._uniform_crossover(mask, np.array(beta.representation))
            elif delta:
                mask = self._uniform_crossover(mask, np.array(delta.representation))
            
            # Light perturbation
            if self.rng.random() < 0.1:
                idx = self.rng.integers(len(mask))
                mask[idx] = 1 - mask[idx]
                mask = self._repair(mask)

            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.evaluate()
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# ABC Exploiter
# =============================================================================

class KnapsackABCExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Artificial Bee Colony for Knapsack EXPLOITATION.
    
    Greedy selection, intensive local search.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 limit: int = 20, local_search_iter: int = 15,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.limit = limit
        self.local_search_iter = local_search_iter
        self._dim = None
        self.rng = np.random.default_rng(seed)
        self.trials: List[int] = []

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
            self.trials = [0] * len(self.population)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        # Employed bee phase with local search
        for i, sol in enumerate(self.population):
            mask = np.array(sol.representation)
            new_mask, new_fit = self._greedy_flip_search(mask, self.local_search_iter)
            
            if new_fit < sol.fitness:
                self.population[i] = Solution(new_mask.tolist(), self.problem)
                self.population[i].fitness = new_fit
                self.trials[i] = 0
            else:
                self.trials[i] += 1

        # Scout phase (reset stagnant from best)
        best = min(self.population, key=lambda s: s.fitness)
        for i in range(len(self.population)):
            if self.trials[i] > self.limit:
                mask = np.array(best.representation)
                idx = self.rng.integers(len(mask))
                mask[idx] = 1 - mask[idx]
                mask = self._repair(mask)
                self.population[i] = Solution(mask.tolist(), self.problem)
                self.population[i].evaluate()
                self.trials[i] = 0

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# WOA Exploiter
# =============================================================================

class KnapsackWOAExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Whale Optimization Algorithm for Knapsack EXPLOITATION.
    
    Encircling emphasis for convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        best = min(self.population, key=lambda s: s.fitness)

        new_population = []
        for sol in self.population:
            mask = np.array(sol.representation)
            
            # Strong encircling of best
            if self.rng.random() < 0.7:
                mask = self._uniform_crossover(mask, np.array(best.representation))
            
            # Light perturbation
            if self.rng.random() < 0.1:
                idx = self.rng.integers(len(mask))
                mask[idx] = 1 - mask[idx]
                mask = self._repair(mask)

            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.evaluate()
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# HHO Exploiter
# =============================================================================

class KnapsackHHOExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Harris Hawks Optimization for Knapsack EXPLOITATION.
    
    Hard besiege emphasis for fast convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 local_search_iter: int = 10, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.local_search_iter = local_search_iter
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        rabbit = min(self.population, key=lambda s: s.fitness)

        new_population = []
        for sol in self.population:
            mask = np.array(sol.representation)
            
            # Hard besiege
            mask = self._uniform_crossover(mask, np.array(rabbit.representation))
            
            # Apply local search
            mask, _ = self._greedy_flip_search(mask, self.local_search_iter)

            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.evaluate()
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# MPA Exploiter
# =============================================================================

class KnapsackMPAExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Marine Predators Algorithm for Knapsack EXPLOITATION.
    
    Brownian motion dominant for local refinement.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        elite = min(self.population, key=lambda s: s.fitness)

        new_population = []
        for sol in self.population:
            mask = np.array(sol.representation)
            
            # Brownian motion (small local moves)
            idx = self.rng.integers(len(mask))
            mask[idx] = 1 - mask[idx]
            mask = self._repair(mask)
            
            # Move toward elite
            if self.rng.random() < 0.5:
                mask = self._uniform_crossover(mask, np.array(elite.representation))

            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.evaluate()
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# SMA Exploiter
# =============================================================================

class KnapsackSMAExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Slime Mould Algorithm for Knapsack EXPLOITATION.
    
    Strong feedback toward best solutions.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        best = min(self.population, key=lambda s: s.fitness)

        new_population = []
        for sol in self.population:
            mask = np.array(sol.representation)
            
            # Strong attraction to best
            if self.rng.random() < 0.8:
                mask = self._uniform_crossover(mask, np.array(best.representation))
            
            # Light perturbation
            if self.rng.random() < 0.15:
                idx = self.rng.integers(len(mask))
                mask[idx] = 1 - mask[idx]
                mask = self._repair(mask)

            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.evaluate()
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# GSA Exploiter
# =============================================================================

class KnapsackGSAExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Gravitational Search Algorithm for Knapsack EXPLOITATION.
    
    High gravitational constant for strong attraction.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 G0: float = 100.0, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.G0 = G0
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        fitnesses = np.array([sol.fitness for sol in self.population])
        worst = fitnesses.max()
        best_fit = fitnesses.min()
        
        if worst - best_fit > 1e-10:
            masses = (worst - fitnesses) / (worst - best_fit)
        else:
            masses = np.ones(len(self.population))
        masses = masses / masses.sum()

        sorted_idx = np.argsort(-masses)
        top_k = sorted_idx[:3]

        new_population = []
        for sol in self.population:
            mask = np.array(sol.representation)
            
            # Strong attraction to heaviest masses
            target_idx = self.rng.choice(top_k)
            mask = self._uniform_crossover(mask, np.array(self.population[target_idx].representation))
            
            # Light local search
            mask, _ = self._greedy_flip_search(mask, 5)

            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.evaluate()
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# Hill Climbing Exploiter
# =============================================================================

class KnapsackHillClimbingExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Hill Climbing for Knapsack EXPLOITATION.
    
    Pure local search with steepest ascent.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 local_search_iter: int = 50, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.local_search_iter = local_search_iter
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        for i, sol in enumerate(self.population):
            mask = np.array(sol.representation)
            improved_mask, improved_fit = self._greedy_flip_search(mask, self.local_search_iter)
            
            self.population[i] = Solution(improved_mask.tolist(), self.problem)
            self.population[i].fitness = improved_fit

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# Memetic Exploiter
# =============================================================================

class KnapsackMemeticExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    Memetic Algorithm for Knapsack EXPLOITATION.
    
    GA + intensive local search on every individual.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 mutation_rate: float = 0.05, local_search_iter: int = 20,
                 elite_ratio: float = 0.2, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.mutation_rate = mutation_rate
        self.local_search_iter = local_search_iter
        self.elite_ratio = elite_ratio
        self._dim = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        n_elite = max(1, int(self.population_size * self.elite_ratio))

        new_population = []
        
        # Keep elite with local search
        for i in range(n_elite):
            mask = np.array(sorted_pop[i].representation)
            improved_mask, improved_fit = self._greedy_flip_search(mask, self.local_search_iter)
            new_sol = Solution(improved_mask.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        # Generate offspring
        while len(new_population) < self.population_size:
            candidates = self.rng.choice(sorted_pop[:n_elite*2], 3, replace=False)
            parent1 = min(candidates, key=lambda s: s.fitness)
            candidates = self.rng.choice(sorted_pop[:n_elite*2], 3, replace=False)
            parent2 = min(candidates, key=lambda s: s.fitness)
            
            mask = self._uniform_crossover(
                np.array(parent1.representation),
                np.array(parent2.representation)
            )
            
            if self.rng.random() < self.mutation_rate:
                idx = self.rng.integers(len(mask))
                mask[idx] = 1 - mask[idx]
                mask = self._repair(mask)
            
            # Apply local search
            improved_mask, improved_fit = self._greedy_flip_search(mask, self.local_search_iter // 2)
            new_sol = Solution(improved_mask.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# L-SHADE Exploiter (Adaptive DE style)
# =============================================================================

class KnapsackLSHADEExploiter(SearchAlgorithm, BinaryKnapsackMixin):
    """
    L-SHADE style adaptive exploiter for Knapsack.
    
    Uses adaptive crossover rates for convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 H: int = 5, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.H = H
        self._dim = None
        self.rng = np.random.default_rng(seed)
        self.M_CR = [0.5] * H
        self.k = 0

    def initialize(self):
        super().initialize()
        if self.population:
            self._dim = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        for sol in self.population:
            if sol.fitness is None:
                sol.evaluate()

        best = min(self.population, key=lambda s: s.fitness)

        S_CR = []
        new_population = []

        for sol in self.population:
            mask = np.array(sol.representation)
            
            # Sample CR from memory
            ri = self.rng.integers(0, self.H)
            CR = np.clip(self.rng.normal(self.M_CR[ri], 0.1), 0, 1)
            
            # Apply crossover with best
            if self.rng.random() < CR:
                mask = self._uniform_crossover(mask, np.array(best.representation))
            
            # Light local search
            mask, new_fit = self._greedy_flip_search(mask, 5)
            
            new_sol = Solution(mask.tolist(), self.problem)
            new_sol.fitness = new_fit
            
            if new_sol.fitness <= sol.fitness:
                new_population.append(new_sol)
                if new_sol.fitness < sol.fitness:
                    S_CR.append(CR)
            else:
                new_population.append(sol)

        # Update memory
        if S_CR:
            self.M_CR[self.k] = np.mean(S_CR)
            self.k = (self.k + 1) % self.H

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1
