"""
MaxCut Exploiter Variants - Configured for CONVERGENCE and LOCAL REFINEMENT.

13 exploiter variants tuned for:
- Low mutation rates
- Strong selection pressure  
- Local search / greedy moves
- Elitism
- Fine-grained refinement

Binary domain with graph-cut structure.
"""

from __future__ import annotations

from typing import List, Optional

import numpy as np

from Core.problem import ProblemInterface, Solution
from Core.search_algorithm import SearchAlgorithm


class MaxCutBinaryMixin:
    """
    Utility mixin for MaxCut binary operations.
    Converts continuous vectors to binary partition masks.
    """

    def _binarize(self, vector: np.ndarray) -> np.ndarray:
        """Convert continuous values to binary using sigmoid threshold."""
        return (vector >= 0.5).astype(int)

    def _make_solution(self, mask: np.ndarray) -> Solution:
        """Create and evaluate a solution from binary mask."""
        sol = Solution(mask.astype(int).tolist(), self.problem)
        sol.evaluate()
        return sol

    def _random_binary(self, size: int) -> np.ndarray:
        """Generate random binary vector."""
        return self.rng.integers(0, 2, size=size)

    @staticmethod
    def _ensure_evaluated(population: List[Solution]) -> None:
        for sol in population:
            if sol.fitness is None:
                sol.evaluate()


# =============================================================================
# 1. Greedy Bit-Flip Exploiter - Local search
# =============================================================================
class MaxCutGreedyExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    Greedy bit-flip hill climbing for MaxCut.
    
    Systematically flips bits and keeps improvements.
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 32,
        *,
        n_flips: int = 10,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutGreedyExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.n_flips = n_flips
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        improved_population: List[Solution] = []
        for sol in self.population:
            current = sol.copy(preserve_id=False)
            current.evaluate()
            mask = np.asarray(current.representation, dtype=int)

            # Try flipping each bit position
            for _ in range(self.n_flips):
                best_improvement = 0
                best_idx = -1

                # Evaluate all single-bit flips
                indices = self.rng.permutation(dim)[: min(dim, 20)]  # Sample for efficiency
                for idx in indices:
                    candidate_mask = mask.copy()
                    candidate_mask[idx] = 1 - candidate_mask[idx]
                    candidate = self._make_solution(candidate_mask)

                    if candidate.fitness is not None and current.fitness is not None:
                        improvement = current.fitness - candidate.fitness
                        if improvement > best_improvement:
                            best_improvement = improvement
                            best_idx = idx

                # Apply best flip if improvement found
                if best_idx >= 0:
                    mask[best_idx] = 1 - mask[best_idx]
                    current = self._make_solution(mask)
                else:
                    break  # No improvement found

            improved_population.append(current)

        # Keep best solutions
        improved_population.sort(key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        self.population = improved_population[: self.population_size]

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 2. GA Exploiter - Genetic Algorithm (exploitation-tuned)
# =============================================================================
class MaxCutGAExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    GA exploiter tuned for convergence:
    - Low mutation rate
    - Strong elitism
    - High selection pressure
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 56,
        *,
        mutation_rate: float = 0.02,
        crossover_rate: float = 0.9,
        elitism_rate: float = 0.1,
        tournament_size: int = 5,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutGAExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.elitism_rate = elitism_rate
        self.tournament_size = tournament_size
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def _tournament_select(self) -> Solution:
        """Strong tournament selection."""
        candidates = self.rng.choice(self.population, size=self.tournament_size, replace=False)
        return min(candidates, key=lambda s: s.fitness if s.fitness is not None else float("inf"))

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        # Preserve elites
        sorted_pop = sorted(
            self.population,
            key=lambda s: s.fitness if s.fitness is not None else float("inf"),
        )
        n_elite = max(1, int(self.elitism_rate * self.population_size))
        elites = [sol.copy(preserve_id=False) for sol in sorted_pop[:n_elite]]

        offspring: List[Solution] = list(elites)
        while len(offspring) < self.population_size:
            parent1 = self._tournament_select()
            parent2 = self._tournament_select()
            mask1 = np.asarray(parent1.representation, dtype=int)
            mask2 = np.asarray(parent2.representation, dtype=int)

            # Two-point crossover
            if self.rng.random() < self.crossover_rate:
                pts = sorted(self.rng.choice(dim, size=2, replace=False))
                child_mask = mask1.copy()
                child_mask[pts[0] : pts[1]] = mask2[pts[0] : pts[1]]
            else:
                child_mask = mask1.copy()

            # Low mutation
            flip = self.rng.random(dim) < self.mutation_rate
            child_mask[flip] = 1 - child_mask[flip]

            offspring.append(self._make_solution(child_mask))

        self.population = offspring[: self.population_size]
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 3. PSO Exploiter - Particle Swarm Optimization (exploitation-tuned)
# =============================================================================
class MaxCutPSOExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    Binary PSO exploiter tuned for exploitation:
    - Low inertia
    - Weak cognitive (personal best)
    - Strong social (global best attraction)
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 48,
        *,
        w: float = 0.4,
        c1: float = 1.0,
        c2: float = 2.5,
        v_max: float = 4.0,
        local_search_iter: int = 5,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutPSOExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.w = w
        self.c1 = c1
        self.c2 = c2
        self.v_max = v_max
        self.local_search_iter = local_search_iter
        self.rng = np.random.default_rng(seed)
        self.velocities: Optional[np.ndarray] = None
        self.pbest: Optional[List[Solution]] = None
        self.gbest: Optional[Solution] = None

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)
        self.velocities = self.rng.uniform(-self.v_max, self.v_max, (self.population_size, dim))
        self.pbest = [sol.copy(preserve_id=False) for sol in self.population]
        self._update_gbest()

    def _update_gbest(self):
        best = min(self.population, key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        if self.gbest is None or (best.fitness is not None and best.fitness < (self.gbest.fitness or float("inf"))):
            self.gbest = best.copy(preserve_id=False)

    def _sigmoid(self, x: np.ndarray) -> np.ndarray:
        return 1.0 / (1.0 + np.exp(-np.clip(x, -500, 500)))

    def _local_search(self, sol: Solution) -> Solution:
        """Apply greedy bit-flip local search."""
        current = sol.copy(preserve_id=False)
        current.evaluate()
        mask = np.asarray(current.representation, dtype=int)
        dim = len(mask)

        for _ in range(self.local_search_iter):
            idx = self.rng.integers(dim)
            candidate_mask = mask.copy()
            candidate_mask[idx] = 1 - candidate_mask[idx]
            candidate = self._make_solution(candidate_mask)

            if candidate.fitness is not None and current.fitness is not None:
                if candidate.fitness < current.fitness:
                    current = candidate
                    mask = candidate_mask

        return current

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        new_population: List[Solution] = []
        for i, sol in enumerate(self.population):
            pos = np.asarray(sol.representation, dtype=float)
            pbest_pos = np.asarray(self.pbest[i].representation, dtype=float)
            gbest_pos = np.asarray(self.gbest.representation, dtype=float)

            r1, r2 = self.rng.random(dim), self.rng.random(dim)
            cognitive = self.c1 * r1 * (pbest_pos - pos)
            social = self.c2 * r2 * (gbest_pos - pos)

            self.velocities[i] = self.w * self.velocities[i] + cognitive + social
            self.velocities[i] = np.clip(self.velocities[i], -self.v_max, self.v_max)

            prob = self._sigmoid(self.velocities[i])
            new_mask = (self.rng.random(dim) < prob).astype(int)

            child = self._make_solution(new_mask)
            # Apply local search
            child = self._local_search(child)
            new_population.append(child)

            # Update personal best
            if child.fitness is not None and (
                self.pbest[i].fitness is None or child.fitness < self.pbest[i].fitness
            ):
                self.pbest[i] = child.copy(preserve_id=False)

        self.population = new_population
        self._update_gbest()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 4. GWO Exploiter - Grey Wolf Optimizer (exploitation-tuned)
# =============================================================================
class MaxCutGWOExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    GWO exploiter tuned for exploitation:
    - Fast a decay (quick convergence)
    - Strong leader attraction
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 40,
        *,
        a_initial: float = 2.0,
        a_final: float = 0.0,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutGWOExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.a_initial = a_initial
        self.a_final = a_final
        self.rng = np.random.default_rng(seed)
        self.max_iterations = 1000

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def _get_leaders(self) -> tuple:
        """Get alpha, beta, delta wolves."""
        sorted_pop = sorted(
            self.population,
            key=lambda s: s.fitness if s.fitness is not None else float("inf"),
        )
        alpha = np.asarray(sorted_pop[0].representation, dtype=float)
        beta = np.asarray(sorted_pop[1].representation, dtype=float) if len(sorted_pop) > 1 else alpha
        delta = np.asarray(sorted_pop[2].representation, dtype=float) if len(sorted_pop) > 2 else beta
        return alpha, beta, delta

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        # Fast decay for exploitation
        progress = min(self.iteration / self.max_iterations, 1.0)
        a = self.a_initial - progress * (self.a_initial - self.a_final)

        alpha, beta, delta = self._get_leaders()

        new_population: List[Solution] = []
        for sol in self.population:
            pos = np.asarray(sol.representation, dtype=float)

            A1 = 2 * a * self.rng.random(dim) - a
            A2 = 2 * a * self.rng.random(dim) - a
            A3 = 2 * a * self.rng.random(dim) - a
            C1 = 2 * self.rng.random(dim)
            C2 = 2 * self.rng.random(dim)
            C3 = 2 * self.rng.random(dim)

            D_alpha = np.abs(C1 * alpha - pos)
            D_beta = np.abs(C2 * beta - pos)
            D_delta = np.abs(C3 * delta - pos)

            X1 = alpha - A1 * D_alpha
            X2 = beta - A2 * D_beta
            X3 = delta - A3 * D_delta

            new_pos = (X1 + X2 + X3) / 3.0
            new_mask = self._binarize(new_pos)

            new_population.append(self._make_solution(new_mask))

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 5. ABC Exploiter - Artificial Bee Colony (exploitation-tuned)
# =============================================================================
class MaxCutABCExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    ABC exploiter tuned for exploitation:
    - High limit (less scout deployment)
    - Small perturbations
    - Focus on best solutions
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 60,
        *,
        limit_factor: float = 3.0,
        perturbation_scale: float = 0.2,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutABCExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.limit_factor = limit_factor
        self.perturbation_scale = perturbation_scale
        self.rng = np.random.default_rng(seed)
        self.trials: Optional[np.ndarray] = None
        self.limit: int = 1

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)
        self.limit = max(1, int(self.limit_factor * dim))
        self.trials = np.zeros(self.population_size, dtype=int)

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        # Employed bee phase - small perturbations
        for i, sol in enumerate(self.population):
            mask = np.asarray(sol.representation, dtype=int).copy()

            # Select partner from better half
            sorted_pop = sorted(
                self.population,
                key=lambda s: s.fitness if s.fitness is not None else float("inf"),
            )
            better_half = sorted_pop[: max(1, self.population_size // 2)]
            partner = self.rng.choice(better_half)
            partner_mask = np.asarray(partner.representation, dtype=int)

            # Small perturbation
            n_flips = max(1, int(self.perturbation_scale * dim * self.rng.random()))
            flip_indices = self.rng.choice(dim, size=min(n_flips, dim), replace=False)

            for idx in flip_indices:
                if self.rng.random() < 0.7:  # Bias toward partner
                    mask[idx] = partner_mask[idx]
                else:
                    mask[idx] = 1 - mask[idx]

            candidate = self._make_solution(mask)
            if candidate.fitness is not None and (sol.fitness is None or candidate.fitness < sol.fitness):
                self.population[i] = candidate
                self.trials[i] = 0
            else:
                self.trials[i] += 1

        # Scout bee phase (rare due to high limit)
        best = min(self.population, key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        for i in range(self.population_size):
            if self.trials[i] >= self.limit:
                # Reinitialize near best solution
                best_mask = np.asarray(best.representation, dtype=int).copy()
                flip = self.rng.random(dim) < 0.1
                best_mask[flip] = 1 - best_mask[flip]
                self.population[i] = self._make_solution(best_mask)
                self.trials[i] = 0

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 6. WOA Exploiter - Whale Optimization Algorithm (exploitation-tuned)
# =============================================================================
class MaxCutWOAExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    WOA exploiter tuned for exploitation:
    - Fast decay
    - More encircling (less random search)
    - Tight spirals
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 36,
        *,
        a_initial: float = 2.0,
        b: float = 0.5,
        encircle_prob: float = 0.7,
        spiral_b: float = 0.5,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutWOAExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.a_initial = a_initial
        self.b = b
        self.encircle_prob = encircle_prob
        self.spiral_b = spiral_b
        self.rng = np.random.default_rng(seed)
        self.max_iterations = 1000

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        # Fast decay
        progress = min(self.iteration / self.max_iterations, 1.0)
        a = self.a_initial * (1 - progress)

        best = min(self.population, key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        best_pos = np.asarray(best.representation, dtype=float)

        new_population: List[Solution] = []
        for sol in self.population:
            pos = np.asarray(sol.representation, dtype=float)
            A = 2 * a * self.rng.random(dim) - a
            C = 2 * self.rng.random(dim)

            if self.rng.random() < self.encircle_prob:
                # Encircling prey (exploitation)
                D = np.abs(C * best_pos - pos)
                new_pos = best_pos - A * D
            else:
                # Tight spiral update
                l = self.rng.uniform(-1, 1, dim)
                D = np.abs(best_pos - pos)
                new_pos = D * np.exp(self.spiral_b * l) * np.cos(2 * np.pi * l) + best_pos

            new_mask = self._binarize(new_pos)
            new_population.append(self._make_solution(new_mask))

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 7. HHO Exploiter - Harris Hawks Optimization (exploitation-tuned)
# =============================================================================
class MaxCutHHOExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    HHO exploiter tuned for exploitation:
    - High exploitation bias
    - Siege behaviors
    - Levy flights for escaping local optima
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 40,
        *,
        exploitation_bias: float = 0.8,
        levy_steps: int = 3,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutHHOExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.exploitation_bias = exploitation_bias
        self.levy_steps = levy_steps
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def _levy_flight(self, dim: int) -> np.ndarray:
        """Generate Levy flight step (small scale for exploitation)."""
        beta = 1.5
        sigma = (
            np.math.gamma(1 + beta)
            * np.sin(np.pi * beta / 2)
            / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))
        ) ** (1 / beta)
        u = self.rng.normal(0, sigma * 0.5, dim)  # Reduced scale
        v = self.rng.normal(0, 1, dim)
        return u / (np.abs(v) ** (1 / beta))

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        rabbit = min(self.population, key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        rabbit_pos = np.asarray(rabbit.representation, dtype=float)

        new_population: List[Solution] = []
        for sol in self.population:
            pos = np.asarray(sol.representation, dtype=float)
            E = 2 * (1 - self.rng.random())  # Escaping energy

            if self.rng.random() < self.exploitation_bias and abs(E) < 1:
                # Exploitation phase
                if self.rng.random() < 0.5:
                    # Soft besiege
                    J = 2 * (1 - self.rng.random(dim))
                    new_pos = rabbit_pos - E * np.abs(J * rabbit_pos - pos)
                else:
                    # Hard besiege with Levy
                    new_pos = rabbit_pos - E * np.abs(rabbit_pos - pos)
                    # Add small Levy perturbation
                    for _ in range(self.levy_steps):
                        levy = self._levy_flight(dim)
                        candidate_pos = new_pos + levy * 0.1
                        candidate = self._make_solution(self._binarize(candidate_pos))
                        current = self._make_solution(self._binarize(new_pos))
                        if candidate.fitness is not None and current.fitness is not None:
                            if candidate.fitness < current.fitness:
                                new_pos = candidate_pos
            else:
                # Soft exploitation around rabbit
                J = 2 * (1 - self.rng.random(dim))
                new_pos = rabbit_pos - pos - E * np.abs(J * rabbit_pos - pos)

            new_mask = self._binarize(new_pos)
            new_population.append(self._make_solution(new_mask))

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 8. MPA Exploiter - Marine Predators Algorithm (exploitation-tuned)
# =============================================================================
class MaxCutMPAExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    MPA exploiter tuned for exploitation:
    - Low FAD probability
    - Small Levy scale
    - Focus on best solutions
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 48,
        *,
        fad_probability: float = 0.05,
        levy_scale: float = 0.5,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutMPAExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.fad_probability = fad_probability
        self.levy_scale = levy_scale
        self.rng = np.random.default_rng(seed)
        self.max_iterations = 1000

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def _levy_flight(self, dim: int) -> np.ndarray:
        """Generate small Levy flight step."""
        beta = 1.5
        sigma = (
            np.math.gamma(1 + beta)
            * np.sin(np.pi * beta / 2)
            / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))
        ) ** (1 / beta)
        u = self.rng.normal(0, sigma, dim)
        v = self.rng.normal(0, 1, dim)
        return self.levy_scale * u / (np.abs(v) ** (1 / beta))

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        progress = min(self.iteration / self.max_iterations, 1.0)
        elite = min(self.population, key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        elite_pos = np.asarray(elite.representation, dtype=float)

        new_population: List[Solution] = []
        for sol in self.population:
            pos = np.asarray(sol.representation, dtype=float)

            if progress < 0.33:
                # Phase 1: Exploration toward elite
                R_B = self.rng.normal(0, 1, dim)
                stepsize = R_B * (elite_pos - R_B * pos) * 0.5
                new_pos = pos + stepsize
            elif progress < 0.66:
                # Phase 2: Mixed with small Levy
                if self.rng.random() < 0.5:
                    R_L = self._levy_flight(dim)
                    stepsize = R_L * (elite_pos - R_L * pos)
                else:
                    R_B = self.rng.normal(0, 1, dim)
                    stepsize = R_B * (elite_pos - R_B * pos) * 0.5
                new_pos = pos + stepsize
            else:
                # Phase 3: Strong exploitation
                CF = (1 - progress) ** 2
                R_L = self._levy_flight(dim)
                stepsize = CF * R_L * (elite_pos - CF * pos)
                new_pos = elite_pos + stepsize * 0.5

            # Rare FAD effect
            if self.rng.random() < self.fad_probability:
                new_pos = new_pos + self.rng.random(dim) * 0.1

            new_mask = self._binarize(new_pos)
            new_population.append(self._make_solution(new_mask))

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 9. SMA Exploiter - Slime Mould Algorithm (exploitation-tuned)
# =============================================================================
class MaxCutSMAExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    SMA exploiter tuned for exploitation:
    - Low random position probability
    - Strong best attraction
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 56,
        *,
        random_position_prob: float = 0.03,
        z: float = 0.03,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutSMAExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.random_position_prob = random_position_prob
        self.z = z
        self.rng = np.random.default_rng(seed)
        self.max_iterations = 1000

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        progress = min(self.iteration / self.max_iterations, 1.0)
        a = np.arctanh(1 - progress)
        b = 1 - progress

        best = min(self.population, key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        best_pos = np.asarray(best.representation, dtype=float)

        # Sort by fitness
        sorted_pop = sorted(
            self.population,
            key=lambda s: s.fitness if s.fitness is not None else float("inf"),
        )
        weights = np.zeros(self.population_size)
        for i, sol in enumerate(sorted_pop):
            if i < self.population_size // 2:
                weights[i] = 1 + self.rng.random() * np.log10((best.fitness + 1e-10) / (sol.fitness + 1e-10) + 1)
            else:
                weights[i] = 1 - self.rng.random() * np.log10((best.fitness + 1e-10) / (sol.fitness + 1e-10) + 1)

        new_population: List[Solution] = []
        for i, sol in enumerate(self.population):
            pos = np.asarray(sol.representation, dtype=float)

            if self.rng.random() < self.random_position_prob:
                # Rare random exploration
                new_pos = best_pos + self.rng.uniform(-0.1, 0.1, dim)
            else:
                p = np.tanh(np.abs(sol.fitness - best.fitness) + 1e-10) if sol.fitness is not None else 0.5
                vb = 2 * a * self.rng.random(dim) - a
                vc = 2 * b * self.rng.random(dim) - b

                if self.rng.random() < p:
                    # Move toward best with weight
                    new_pos = best_pos + vb * (weights[min(i, len(weights) - 1)] * best_pos - pos)
                else:
                    new_pos = vc * pos

            new_mask = self._binarize(new_pos)
            new_population.append(self._make_solution(new_mask))

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 10. GSA Exploiter - Gravitational Search Algorithm (exploitation-tuned)
# =============================================================================
class MaxCutGSAExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    GSA exploiter tuned for exploitation:
    - Moderate G0
    - High alpha (fast decay)
    - Low k_best ratio (focus on best)
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 48,
        *,
        G0: float = 100.0,
        alpha: float = 30.0,
        k_best_ratio: float = 0.3,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutGSAExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.G0 = G0
        self.alpha = alpha
        self.k_best_ratio = k_best_ratio
        self.rng = np.random.default_rng(seed)
        self.velocities: Optional[np.ndarray] = None
        self.max_iterations = 1000

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)
        self.velocities = np.zeros((self.population_size, dim))

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        progress = min(self.iteration / self.max_iterations, 1.0)
        G = self.G0 * np.exp(-self.alpha * progress)

        # Calculate masses
        fitnesses = np.array([s.fitness if s.fitness is not None else float("inf") for s in self.population])
        worst = np.max(fitnesses[fitnesses < float("inf")]) if np.any(fitnesses < float("inf")) else 1.0
        best_fit = np.min(fitnesses)

        masses = np.zeros(self.population_size)
        for i, fit in enumerate(fitnesses):
            if fit < float("inf"):
                masses[i] = (worst - fit) / (worst - best_fit + 1e-10)
        masses = masses / (np.sum(masses) + 1e-10)

        # K best agents (few for exploitation)
        k = max(1, int(self.k_best_ratio * self.population_size * (1 - progress)))
        sorted_indices = np.argsort(fitnesses)[:k]

        # Calculate forces
        positions = np.array([np.asarray(s.representation, dtype=float) for s in self.population])
        forces = np.zeros((self.population_size, dim))

        for i in range(self.population_size):
            for j in sorted_indices:
                if i != j:
                    R = np.linalg.norm(positions[i] - positions[j]) + 1e-10
                    force_mag = G * masses[i] * masses[j] / R
                    forces[i] += self.rng.random(dim) * force_mag * (positions[j] - positions[i])

        # Update velocities and positions
        new_population: List[Solution] = []
        for i in range(self.population_size):
            if masses[i] > 1e-10:
                acc = forces[i] / masses[i]
            else:
                acc = forces[i]

            self.velocities[i] = self.rng.random(dim) * self.velocities[i] + acc
            new_pos = positions[i] + self.velocities[i]
            new_mask = self._binarize(new_pos)
            new_population.append(self._make_solution(new_mask))

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 11. Hill Climbing Exploiter - Pure local search
# =============================================================================
class MaxCutHillClimbingExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    Pure hill climbing exploiter:
    - Systematic neighborhood search
    - First/best improvement
    - Multiple restarts from elite pool
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 24,
        *,
        n_neighbors: int = 10,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutHillClimbingExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.n_neighbors = n_neighbors
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        improved_population: List[Solution] = []
        for sol in self.population:
            current = sol.copy(preserve_id=False)
            current.evaluate()
            mask = np.asarray(current.representation, dtype=int)

            # Try multiple neighbors
            improved = True
            while improved:
                improved = False
                # Random sample of positions
                positions = self.rng.permutation(dim)[: self.n_neighbors]
                
                for idx in positions:
                    candidate_mask = mask.copy()
                    candidate_mask[idx] = 1 - candidate_mask[idx]
                    candidate = self._make_solution(candidate_mask)

                    if candidate.fitness is not None and current.fitness is not None:
                        if candidate.fitness < current.fitness:
                            current = candidate
                            mask = candidate_mask
                            improved = True
                            break  # First improvement

            improved_population.append(current)

        improved_population.sort(key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        self.population = improved_population[: self.population_size]

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 12. Memetic Exploiter - GA + Local Search
# =============================================================================
class MaxCutMemeticExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    Memetic algorithm exploiter:
    - GA operations with local search
    - High local search probability
    - Multiple improvement steps
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 40,
        *,
        mutation_rate: float = 0.05,
        local_search_prob: float = 0.8,
        local_search_steps: int = 10,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutMemeticExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.mutation_rate = mutation_rate
        self.local_search_prob = local_search_prob
        self.local_search_steps = local_search_steps
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)

    def _local_search(self, sol: Solution) -> Solution:
        """Apply greedy local search."""
        current = sol.copy(preserve_id=False)
        current.evaluate()
        mask = np.asarray(current.representation, dtype=int)
        dim = len(mask)

        for _ in range(self.local_search_steps):
            best_candidate = current
            best_mask = mask

            # Evaluate sample of neighbors
            indices = self.rng.permutation(dim)[: min(dim, 10)]
            for idx in indices:
                candidate_mask = mask.copy()
                candidate_mask[idx] = 1 - candidate_mask[idx]
                candidate = self._make_solution(candidate_mask)

                if candidate.fitness is not None and best_candidate.fitness is not None:
                    if candidate.fitness < best_candidate.fitness:
                        best_candidate = candidate
                        best_mask = candidate_mask

            if best_candidate is not current:
                current = best_candidate
                mask = best_mask
            else:
                break

        return current

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        # Preserve elites
        sorted_pop = sorted(
            self.population,
            key=lambda s: s.fitness if s.fitness is not None else float("inf"),
        )
        elites = [sol.copy(preserve_id=False) for sol in sorted_pop[:2]]

        offspring: List[Solution] = list(elites)
        while len(offspring) < self.population_size:
            # Tournament selection
            candidates = self.rng.choice(self.population, size=3, replace=False)
            parent1 = min(candidates, key=lambda s: s.fitness if s.fitness is not None else float("inf"))
            candidates = self.rng.choice(self.population, size=3, replace=False)
            parent2 = min(candidates, key=lambda s: s.fitness if s.fitness is not None else float("inf"))

            mask1 = np.asarray(parent1.representation, dtype=int)
            mask2 = np.asarray(parent2.representation, dtype=int)

            # Uniform crossover
            swap = self.rng.random(dim) < 0.5
            child_mask = np.where(swap, mask2, mask1)

            # Low mutation
            flip = self.rng.random(dim) < self.mutation_rate
            child_mask[flip] = 1 - child_mask[flip]

            child = self._make_solution(child_mask)

            # Apply local search
            if self.rng.random() < self.local_search_prob:
                child = self._local_search(child)

            offspring.append(child)

        self.population = offspring[: self.population_size]
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# 13. L-SHADE Exploiter - Adaptive DE
# =============================================================================
class MaxCutLSHADEExploiter(MaxCutBinaryMixin, SearchAlgorithm):
    """
    L-SHADE style adaptive exploiter:
    - Self-adaptive parameters
    - Linear population reduction
    - Success history
    """
    phase = "exploitation"

    def __init__(
        self,
        problem: ProblemInterface,
        population_size: int = 64,
        *,
        p_best_rate: float = 0.05,
        H: int = 5,
        seed: Optional[int] = None,
    ):
        if not hasattr(problem, "maxcut_problem"):
            raise ValueError("MaxCutLSHADEExploiter expects a MaxCutAdapter.")
        super().__init__(problem, population_size)
        self.p_best_rate = p_best_rate
        self.H = H
        self.rng = np.random.default_rng(seed)
        self.M_CR: Optional[np.ndarray] = None
        self.M_F: Optional[np.ndarray] = None
        self.k: int = 0
        self.max_iterations = 1000
        self.min_population = 4

    def initialize(self):
        super().initialize()
        self._ensure_evaluated(self.population)
        self.M_CR = np.full(self.H, 0.5)
        self.M_F = np.full(self.H, 0.5)
        self.k = 0

    def step(self):
        self._ensure_evaluated(self.population)
        dim = len(self.population[0].representation)

        S_CR, S_F = [], []

        # Sort population
        sorted_pop = sorted(
            self.population,
            key=lambda s: s.fitness if s.fitness is not None else float("inf"),
        )

        offspring: List[Solution] = []
        for i, sol in enumerate(self.population):
            # Generate CR and F
            r = self.rng.integers(self.H)
            CR = np.clip(self.rng.normal(self.M_CR[r], 0.1), 0, 1)
            F = np.clip(self.rng.standard_cauchy() * 0.1 + self.M_F[r], 0.01, 1)

            mask = np.asarray(sol.representation, dtype=float)

            # Select p-best
            p = max(2, int(self.p_best_rate * len(self.population)))
            p_best = sorted_pop[self.rng.integers(p)]
            p_best_mask = np.asarray(p_best.representation, dtype=float)

            # Select random individuals
            r1 = self.rng.integers(len(self.population))
            while r1 == i:
                r1 = self.rng.integers(len(self.population))
            r2 = self.rng.integers(len(self.population))
            while r2 == i or r2 == r1:
                r2 = self.rng.integers(len(self.population))

            x_r1 = np.asarray(self.population[r1].representation, dtype=float)
            x_r2 = np.asarray(self.population[r2].representation, dtype=float)

            # Mutation
            mutant = mask + F * (p_best_mask - mask) + F * (x_r1 - x_r2)

            # Binomial crossover
            j_rand = self.rng.integers(dim)
            trial_mask = np.where(
                (self.rng.random(dim) < CR) | (np.arange(dim) == j_rand),
                mutant,
                mask,
            )

            trial = self._make_solution(self._binarize(trial_mask))

            # Selection
            if trial.fitness is not None and sol.fitness is not None and trial.fitness <= sol.fitness:
                offspring.append(trial)
                if trial.fitness < sol.fitness:
                    S_CR.append(CR)
                    S_F.append(F)
            else:
                offspring.append(sol.copy(preserve_id=False))

        # Update memory
        if S_CR and S_F:
            self.M_CR[self.k] = np.mean(S_CR)
            self.M_F[self.k] = np.sum(np.array(S_F) ** 2) / np.sum(S_F) if np.sum(S_F) > 0 else 0.5
            self.k = (self.k + 1) % self.H

        # Linear population reduction
        progress = min(self.iteration / self.max_iterations, 1.0)
        target_pop = max(
            self.min_population,
            int(self.population_size - progress * (self.population_size - self.min_population)),
        )

        offspring.sort(key=lambda s: s.fitness if s.fitness is not None else float("inf"))
        self.population = offspring[:target_pop]

        self._update_best_solution()
        self.iteration += 1


__all__ = [
    "MaxCutGreedyExploiter",
    "MaxCutGAExploiter",
    "MaxCutPSOExploiter",
    "MaxCutGWOExploiter",
    "MaxCutABCExploiter",
    "MaxCutWOAExploiter",
    "MaxCutHHOExploiter",
    "MaxCutMPAExploiter",
    "MaxCutSMAExploiter",
    "MaxCutGSAExploiter",
    "MaxCutHillClimbingExploiter",
    "MaxCutMemeticExploiter",
    "MaxCutLSHADEExploiter",
]
