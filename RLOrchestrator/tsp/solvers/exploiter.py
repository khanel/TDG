"""
TSP Exploiter using intensive 2-opt local search.
"""

from __future__ import annotations

from typing import List

import numpy as np

from Core.problem import ProblemInterface, Solution
from Core.search_algorithm import SearchAlgorithm


class TSPPSOExploiter(SearchAlgorithm):
    """
    TSP Exploiter using intensive 2-opt local search.
    
    Focuses population on best solutions and applies local search
    to refine tours toward local optima.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int, 
                 elite_ratio: float = 0.3,
                 local_search_iterations: int = 10, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.elite_ratio = elite_ratio
        self.local_search_iterations = local_search_iterations
        self._num_cities = None

    def initialize(self):
        """Initialize population."""
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        """One step of exploitation: local search on elite, focus population."""
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)
        
        # Sort by fitness
        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        n_elite = max(1, int(self.population_size * self.elite_ratio))
        
        new_population = []
        
        # Apply local search to elite solutions
        for idx in range(n_elite):
            tour = np.array(sorted_pop[idx].representation)
            improved_tour, improved_fit = self._two_opt_local_search(tour)
            
            new_sol = Solution(improved_tour.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)
        
        # Fill rest of population from elite with small perturbations
        while len(new_population) < self.population_size:
            elite_idx = np.random.randint(0, n_elite)
            elite_tour = np.array(sorted_pop[elite_idx].representation)
            
            # Small perturbation: 1-3 swap moves
            perturbed = elite_tour.copy()
            n_swaps = np.random.randint(1, 4)
            for _ in range(n_swaps):
                i, j = np.random.choice(self._num_cities, 2, replace=False)
                perturbed[i], perturbed[j] = perturbed[j], perturbed[i]
            
            new_sol = Solution(perturbed.tolist(), self.problem)
            new_population.append(new_sol)
        
        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1

    def _two_opt_local_search(self, tour: np.ndarray) -> tuple:
        """Apply 2-opt local search until no improvement."""
        current_tour = tour.copy()
        
        # Create temporary solution for evaluation
        temp_sol = Solution(current_tour.tolist(), self.problem)
        temp_sol.evaluate()
        current_fitness = temp_sol.fitness
        
        improved = True
        iterations = 0
        
        while improved and iterations < self.local_search_iterations:
            improved = False
            iterations += 1
            
            # Try random 2-opt moves
            for _ in range(self._num_cities):
                i, j = sorted(np.random.choice(self._num_cities, 2, replace=False))
                if j - i < 2:
                    continue
                
                # Try reversing segment
                new_tour = current_tour.copy()
                new_tour[i:j+1] = new_tour[i:j+1][::-1]
                
                temp_sol = Solution(new_tour.tolist(), self.problem)
                temp_sol.evaluate()
                
                if temp_sol.fitness < current_fitness:
                    current_tour = new_tour
                    current_fitness = temp_sol.fitness
                    improved = True
                    break
        
        return current_tour, current_fitness

    def ingest_population(self, seeds: List[Solution]):
        """Ingest population and immediately apply local search to best."""
        super().ingest_population(seeds)
        
        if not self.population:
            return
        
        self._num_cities = len(self.population[0].representation)
        
        # Apply light local search to top solutions
        sorted_pop = sorted(self.population, key=lambda s: s.fitness if s.fitness else float('inf'))
        n_improve = min(3, len(sorted_pop))
        
        for idx in range(n_improve):
            if sorted_pop[idx].fitness is not None:
                tour = np.array(sorted_pop[idx].representation)
                improved_tour, improved_fit = self._two_opt_local_search(tour)
                sorted_pop[idx].representation = improved_tour.tolist()
                sorted_pop[idx].fitness = improved_fit
        
        self.population = sorted_pop
        self.mark_best_dirty()
        self._update_best_solution()
