"""
TSP Exploiter Variants - Configured for CONVERGENCE and LOCAL REFINEMENT.

All exploiters are tuned to:
- Converge population toward best solutions
- Apply intensive local search
- Refine tours toward local optima
- Support permutation-based TSP representation

Key tuning principles:
- Low randomness
- High selection pressure
- Strong attraction to best
- Intensive 2-opt / 3-opt local search
"""

from __future__ import annotations

from typing import List, Optional

import numpy as np

from Core.problem import ProblemInterface, Solution
from Core.search_algorithm import SearchAlgorithm


# =============================================================================
# Permutation Utilities (shared with explorers)
# =============================================================================

class PermutationMixin:
    """Provides permutation operations for TSP solvers."""
    
    def _order_crossover(self, parent1: np.ndarray, parent2: np.ndarray) -> np.ndarray:
        """Order Crossover (OX) for permutations."""
        n = len(parent1)
        start, end = sorted(np.random.choice(n, 2, replace=False))
        child = np.full(n, -1)
        child[start:end+1] = parent1[start:end+1]
        segment_set = set(child[start:end+1])
        p2_remaining = [x for x in parent2 if x not in segment_set]
        idx = 0
        for i in range(n):
            if child[i] == -1:
                child[i] = p2_remaining[idx]
                idx += 1
        return child

    def _two_opt_move(self, tour: np.ndarray) -> np.ndarray:
        """Apply a single 2-opt move (reverse a segment)."""
        n = len(tour)
        i, j = sorted(np.random.choice(n, 2, replace=False))
        new_tour = tour.copy()
        new_tour[i:j+1] = new_tour[i:j+1][::-1]
        return new_tour

    def _or_opt_move(self, tour: np.ndarray) -> np.ndarray:
        """Or-opt: relocate a segment of 1-3 cities."""
        n = len(tour)
        seg_len = np.random.randint(1, min(4, n-1))
        start = np.random.randint(0, n - seg_len)
        segment = tour[start:start+seg_len].copy()
        remaining = np.concatenate([tour[:start], tour[start+seg_len:]])
        insert_pos = np.random.randint(0, len(remaining) + 1)
        return np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])

    def _swap_move(self, tour: np.ndarray) -> np.ndarray:
        """Swap two random cities."""
        n = len(tour)
        i, j = np.random.choice(n, 2, replace=False)
        new_tour = tour.copy()
        new_tour[i], new_tour[j] = new_tour[j], new_tour[i]
        return new_tour

    def _two_opt_local_search(self, tour: np.ndarray, max_iter: int = 20) -> tuple:
        """Apply 2-opt local search until no improvement."""
        current_tour = tour.copy()
        temp_sol = Solution(current_tour.tolist(), self.problem)
        temp_sol.evaluate()
        current_fitness = temp_sol.fitness
        
        improved = True
        iterations = 0
        n = len(tour)
        
        while improved and iterations < max_iter:
            improved = False
            iterations += 1
            
            for _ in range(n * 2):
                i, j = sorted(np.random.choice(n, 2, replace=False))
                if j - i < 2:
                    continue
                
                new_tour = current_tour.copy()
                new_tour[i:j+1] = new_tour[i:j+1][::-1]
                
                temp_sol = Solution(new_tour.tolist(), self.problem)
                temp_sol.evaluate()
                
                if temp_sol.fitness < current_fitness:
                    current_tour = new_tour
                    current_fitness = temp_sol.fitness
                    improved = True
                    break
        
        return current_tour, current_fitness


# =============================================================================
# 2-opt Local Search Exploiter
# =============================================================================

class TSP2OptExploiter(SearchAlgorithm, PermutationMixin):
    """
    Intensive 2-opt local search exploiter for TSP.
    
    Primary exploitation strategy: apply 2-opt to elite solutions.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 elite_ratio: float = 0.4, local_search_iter: int = 30,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.elite_ratio = elite_ratio
        self.local_search_iter = local_search_iter
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        n_elite = max(1, int(self.population_size * self.elite_ratio))

        new_population = []

        # Apply intensive local search to elite
        for idx in range(n_elite):
            tour = np.array(sorted_pop[idx].representation)
            improved_tour, improved_fit = self._two_opt_local_search(tour, self.local_search_iter)
            new_sol = Solution(improved_tour.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        # Fill rest from elite with small perturbations
        while len(new_population) < self.population_size:
            elite_idx = self.rng.integers(0, n_elite)
            tour = np.array(sorted_pop[elite_idx].representation)
            
            # Small perturbation
            tour = self._swap_move(tour)
            
            # Light local search
            improved_tour, improved_fit = self._two_opt_local_search(tour, 5)
            new_sol = Solution(improved_tour.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# GA Exploiter
# =============================================================================

class TSPGAExploiter(SearchAlgorithm, PermutationMixin):
    """
    Genetic Algorithm for TSP EXPLOITATION.
    
    Strong elitism, low mutation, high selection pressure.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 mutation_rate: float = 0.1, elite_ratio: float = 0.3,
                 tournament_size: int = 5, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.mutation_rate = mutation_rate
        self.elite_ratio = elite_ratio
        self.tournament_size = tournament_size
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        n_elite = max(1, int(self.population_size * self.elite_ratio))

        new_population = []
        
        # Strong elitism
        for i in range(n_elite):
            new_population.append(sorted_pop[i].copy(preserve_id=False))

        while len(new_population) < self.population_size:
            parent1 = self._tournament_select()
            parent2 = self._tournament_select()
            
            tour = self._order_crossover(
                np.array(parent1.representation),
                np.array(parent2.representation)
            )
            
            # Light mutation
            if self.rng.random() < self.mutation_rate:
                tour = self._swap_move(tour)

            sol = Solution(tour.tolist(), self.problem)
            new_population.append(sol)

        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1

    def _tournament_select(self) -> Solution:
        """Strong tournament selection."""
        candidates = self.rng.choice(self.population, self.tournament_size, replace=False)
        return min(candidates, key=lambda s: s.fitness)


# =============================================================================
# PSO Exploiter
# =============================================================================

class TSPPSOExploiter(SearchAlgorithm, PermutationMixin):
    """
    Particle Swarm Optimization for TSP EXPLOITATION.
    
    High social component, low cognitive for convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 cognitive: float = 0.3, social: float = 0.7,
                 local_search_iter: int = 10, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.cognitive = cognitive
        self.social = social
        self.local_search_iter = local_search_iter
        self._num_cities = None
        self.rng = np.random.default_rng(seed)
        self.pbest: List[Solution] = []
        self.gbest: Optional[Solution] = None

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
            self.pbest = [sol.copy(preserve_id=False) for sol in self.population]
            self.gbest = min(self.pbest, key=lambda s: s.fitness)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        for i, sol in enumerate(self.population):
            tour = np.array(sol.representation)
            
            # Strong attraction to global best
            if self.rng.random() < self.social and self.gbest:
                tour = self._order_crossover(tour, np.array(self.gbest.representation))
            
            # Weaker attraction to personal best
            if self.rng.random() < self.cognitive:
                tour = self._order_crossover(tour, np.array(self.pbest[i].representation))
            
            # Apply local search
            tour, fitness = self._two_opt_local_search(tour, self.local_search_iter)

            new_sol = Solution(tour.tolist(), self.problem)
            new_sol.fitness = fitness
            self.population[i] = new_sol

            # Update personal best
            if new_sol.fitness < self.pbest[i].fitness:
                self.pbest[i] = new_sol.copy(preserve_id=False)

        # Update global best
        current_best = min(self.population, key=lambda s: s.fitness)
        if self.gbest is None or current_best.fitness < self.gbest.fitness:
            self.gbest = current_best.copy(preserve_id=False)

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# GWO Exploiter
# =============================================================================

class TSPGWOExploiter(SearchAlgorithm, PermutationMixin):
    """
    Grey Wolf Optimizer for TSP EXPLOITATION.
    
    Strong hierarchy, fast convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 a_decay: float = 2.0, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.a_decay = a_decay
        self._num_cities = None
        self.rng = np.random.default_rng(seed)
        self.alpha: Optional[Solution] = None
        self.beta: Optional[Solution] = None
        self.delta: Optional[Solution] = None

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
            self._update_hierarchy()
        self._update_best_solution()

    def _update_hierarchy(self):
        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        self.alpha = sorted_pop[0] if len(sorted_pop) > 0 else None
        self.beta = sorted_pop[1] if len(sorted_pop) > 1 else self.alpha
        self.delta = sorted_pop[2] if len(sorted_pop) > 2 else self.beta

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        new_population = []
        for sol in self.population:
            tour = np.array(sol.representation)
            
            # Strong encircling of alpha
            if self.alpha and self.rng.random() < 0.6:
                tour = self._order_crossover(tour, np.array(self.alpha.representation))
            elif self.beta and self.rng.random() < 0.3:
                tour = self._order_crossover(tour, np.array(self.beta.representation))
            elif self.delta:
                tour = self._order_crossover(tour, np.array(self.delta.representation))
            
            # Light perturbation
            if self.rng.random() < 0.2:
                tour = self._swap_move(tour)

            new_sol = Solution(tour.tolist(), self.problem)
            new_population.append(new_sol)

        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_hierarchy()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# ABC Exploiter
# =============================================================================

class TSPABCExploiter(SearchAlgorithm, PermutationMixin):
    """
    Artificial Bee Colony for TSP EXPLOITATION.
    
    Greedy selection, intensive local search on employed bees.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 limit: int = 20, local_search_iter: int = 15,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.limit = limit
        self.local_search_iter = local_search_iter
        self._num_cities = None
        self.rng = np.random.default_rng(seed)
        self.trials: List[int] = []

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
            self.trials = [0] * len(self.population)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        # Employed bee phase with local search
        for i, sol in enumerate(self.population):
            tour = np.array(sol.representation)
            new_tour, new_fit = self._two_opt_local_search(tour, self.local_search_iter)
            
            if new_fit < sol.fitness:
                self.population[i] = Solution(new_tour.tolist(), self.problem)
                self.population[i].fitness = new_fit
                self.trials[i] = 0
            else:
                self.trials[i] += 1

        # Onlooker bee phase (greedy selection)
        fitnesses = np.array([1.0 / (1.0 + sol.fitness) for sol in self.population])
        probs = fitnesses / fitnesses.sum()
        
        for _ in range(self.population_size):
            idx = self.rng.choice(len(self.population), p=probs)
            tour = np.array(self.population[idx].representation)
            new_tour, new_fit = self._two_opt_local_search(tour, 5)
            
            if new_fit < self.population[idx].fitness:
                self.population[idx] = Solution(new_tour.tolist(), self.problem)
                self.population[idx].fitness = new_fit
                self.trials[idx] = 0

        # Scout phase (reset stagnant)
        best = min(self.population, key=lambda s: s.fitness)
        best_tour = np.array(best.representation)

        for i in range(len(self.population)):
            if self.trials[i] > self.limit:
                # Reset from best with perturbation.
                tour = best_tour.copy()
                for _ in range(3):
                    tour = self._swap_move(tour)
                new_sol = Solution(tour.tolist(), self.problem)
                new_sol.evaluate()
                self.population[i] = new_sol
                self.trials[i] = 0

        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# WOA Exploiter
# =============================================================================

class TSPWOAExploiter(SearchAlgorithm, PermutationMixin):
    """
    Whale Optimization Algorithm for TSP EXPLOITATION.
    
    Encircling emphasis for convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 b: float = 1.0, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.b = b
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        best = min(self.population, key=lambda s: s.fitness)

        new_population = []
        for sol in self.population:
            tour = np.array(sol.representation)
            
            # Strong encircling of best
            if self.rng.random() < 0.7:
                tour = self._order_crossover(tour, np.array(best.representation))
            
            # Light perturbation
            if self.rng.random() < 0.2:
                tour = self._swap_move(tour)

            new_sol = Solution(tour.tolist(), self.problem)
            new_population.append(new_sol)

        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# HHO Exploiter
# =============================================================================

class TSPHHOExploiter(SearchAlgorithm, PermutationMixin):
    """
    Harris Hawks Optimization for TSP EXPLOITATION.
    
    Hard besiege emphasis for fast convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        rabbit = min(self.population, key=lambda s: s.fitness)

        new_population = []
        for sol in self.population:
            tour = np.array(sol.representation)
            
            # Hard besiege (strong convergence)
            tour = self._order_crossover(tour, np.array(rabbit.representation))
            
            # Apply local search
            tour, _ = self._two_opt_local_search(tour, 10)

            new_sol = Solution(tour.tolist(), self.problem)
            new_population.append(new_sol)

        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# MPA Exploiter
# =============================================================================

class TSPMPAExploiter(SearchAlgorithm, PermutationMixin):
    """
    Marine Predators Algorithm for TSP EXPLOITATION.
    
    Brownian motion dominant for local refinement.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        elite = min(self.population, key=lambda s: s.fitness)

        new_population = []
        for sol in self.population:
            tour = np.array(sol.representation)
            
            # Brownian motion (small local moves)
            tour = self._swap_move(tour)
            if self.rng.random() < 0.3:
                tour = self._two_opt_move(tour)
            
            # Move toward elite
            if self.rng.random() < 0.5:
                tour = self._order_crossover(tour, np.array(elite.representation))

            new_sol = Solution(tour.tolist(), self.problem)
            new_population.append(new_sol)

        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# SMA Exploiter
# =============================================================================

class TSPSMAExploiter(SearchAlgorithm, PermutationMixin):
    """
    Slime Mould Algorithm for TSP EXPLOITATION.
    
    Strong feedback toward best solutions.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        best = sorted_pop[0]

        new_population = []
        for sol in self.population:
            tour = np.array(sol.representation)
            
            # Strong attraction to best
            if self.rng.random() < 0.8:
                tour = self._order_crossover(tour, np.array(best.representation))
            
            # Light perturbation
            if self.rng.random() < 0.3:
                tour = self._swap_move(tour)

            new_sol = Solution(tour.tolist(), self.problem)
            new_population.append(new_sol)

        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# GSA Exploiter
# =============================================================================

class TSPGSAExploiter(SearchAlgorithm, PermutationMixin):
    """
    Gravitational Search Algorithm for TSP EXPLOITATION.
    
    High gravitational constant for strong attraction.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 G0: float = 100.0, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.G0 = G0
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        # Compute masses
        fitnesses = np.array([sol.fitness for sol in self.population])
        worst = fitnesses.max()
        best_fit = fitnesses.min()
        
        if worst - best_fit > 1e-10:
            masses = (worst - fitnesses) / (worst - best_fit)
        else:
            masses = np.ones(len(self.population))
        masses = masses / masses.sum()

        # Sort by mass to find heaviest
        sorted_idx = np.argsort(-masses)
        top_k = sorted_idx[:3]

        new_population = []
        for i, sol in enumerate(self.population):
            tour = np.array(sol.representation)
            
            # Strong attraction to heaviest masses
            target_idx = self.rng.choice(top_k)
            tour = self._order_crossover(tour, np.array(self.population[target_idx].representation))
            
            # Light local search
            tour, _ = self._two_opt_local_search(tour, 5)

            new_sol = Solution(tour.tolist(), self.problem)
            new_population.append(new_sol)

        self.population = new_population
        self.mark_best_dirty()
        self.ensure_population_evaluated()
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# Hill Climbing Exploiter
# =============================================================================

class TSPHillClimbingExploiter(SearchAlgorithm, PermutationMixin):
    """
    Hill Climbing for TSP EXPLOITATION.
    
    Pure local search with steepest ascent.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 local_search_iter: int = 50, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.local_search_iter = local_search_iter
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        for i, sol in enumerate(self.population):
            tour = np.array(sol.representation)
            improved_tour, improved_fit = self._two_opt_local_search(tour, self.local_search_iter)
            
            self.population[i] = Solution(improved_tour.tolist(), self.problem)
            self.population[i].fitness = improved_fit

        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# Memetic Exploiter
# =============================================================================

class TSPMemeticExploiter(SearchAlgorithm, PermutationMixin):
    """
    Memetic Algorithm for TSP EXPLOITATION.
    
    GA + intensive local search on every individual.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 mutation_rate: float = 0.1, local_search_iter: int = 20,
                 elite_ratio: float = 0.2, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.mutation_rate = mutation_rate
        self.local_search_iter = local_search_iter
        self.elite_ratio = elite_ratio
        self._num_cities = None
        self.rng = np.random.default_rng(seed)

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        n_elite = max(1, int(self.population_size * self.elite_ratio))

        new_population = []
        
        # Keep elite with local search
        for i in range(n_elite):
            tour = np.array(sorted_pop[i].representation)
            improved_tour, improved_fit = self._two_opt_local_search(tour, self.local_search_iter)
            new_sol = Solution(improved_tour.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        # Generate offspring
        while len(new_population) < self.population_size:
            # Tournament selection
            candidates = self.rng.choice(sorted_pop[:n_elite*2], 3, replace=False)
            parent1 = min(candidates, key=lambda s: s.fitness)
            candidates = self.rng.choice(sorted_pop[:n_elite*2], 3, replace=False)
            parent2 = min(candidates, key=lambda s: s.fitness)
            
            tour = self._order_crossover(
                np.array(parent1.representation),
                np.array(parent2.representation)
            )
            
            if self.rng.random() < self.mutation_rate:
                tour = self._swap_move(tour)
            
            # Apply local search
            improved_tour, improved_fit = self._two_opt_local_search(tour, self.local_search_iter // 2)
            new_sol = Solution(improved_tour.tolist(), self.problem)
            new_sol.fitness = improved_fit
            new_population.append(new_sol)

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1


# =============================================================================
# L-SHADE Exploiter (Adaptive DE)
# =============================================================================

class TSPLSHADEExploiter(SearchAlgorithm, PermutationMixin):
    """
    L-SHADE style adaptive exploiter for TSP.
    
    Uses adaptive crossover rates for convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int,
                 H: int = 5, seed: Optional[int] = None, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.H = H
        self._num_cities = None
        self.rng = np.random.default_rng(seed)
        self.M_CR = [0.5] * H
        self.k = 0

    def initialize(self):
        super().initialize()
        if self.population:
            self._num_cities = len(self.population[0].representation)
        self._update_best_solution()

    def step(self):
        self.ensure_population_evaluated()
        
        if self._num_cities is None and self.population:
            self._num_cities = len(self.population[0].representation)

        sorted_pop = sorted(self.population, key=lambda s: s.fitness)
        best = sorted_pop[0]

        S_CR = []
        new_population = []

        for sol in self.population:
            tour = np.array(sol.representation)
            
            # Sample CR from memory
            ri = self.rng.integers(0, self.H)
            CR = np.clip(self.rng.normal(self.M_CR[ri], 0.1), 0, 1)
            
            # Apply crossover with best
            if self.rng.random() < CR:
                tour = self._order_crossover(tour, np.array(best.representation))
            
            # Light local search
            tour, new_fit = self._two_opt_local_search(tour, 5)
            
            new_sol = Solution(tour.tolist(), self.problem)
            new_sol.fitness = new_fit
            
            if new_sol.fitness <= sol.fitness:
                new_population.append(new_sol)
                if new_sol.fitness < sol.fitness:
                    S_CR.append(CR)
            else:
                new_population.append(sol)

        # Update memory
        if S_CR:
            self.M_CR[self.k] = np.mean(S_CR)
            self.k = (self.k + 1) % self.H

        self.population = new_population
        self._update_best_solution()
        self.iteration += 1
