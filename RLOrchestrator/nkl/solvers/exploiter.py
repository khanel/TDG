"""Binary Particle Swarm Optimization for EXPLOITATION."""

from __future__ import annotations

from typing import List

import numpy as np

from Core.problem import ProblemInterface, Solution
from Core.search_algorithm import SearchAlgorithm


class NKLBinaryPSOExploiter(SearchAlgorithm):
    """
    Binary Particle Swarm Optimization for PURE EXPLOITATION.
    
    Uses deterministic bit-flip based on velocity sign for strong convergence.
    """
    phase = "exploitation"

    def __init__(self, problem: ProblemInterface, population_size: int, omega: float = 0.7,
                 c1: float = 1.5, c2: float = 2.0, vmax: float = 4.0, **kwargs):
        super().__init__(problem, population_size, **kwargs)
        self.omega = omega
        self.c1 = c1
        self.c2 = c2
        self.vmax = vmax
        
        self.velocities = None
        self.personal_bests = None
        self.personal_best_fitness = None
        self.global_best = None
        self.global_best_fitness = float('inf')
        self._dimension = None

    def initialize(self):
        """Initialize the swarm."""
        super().initialize()
        
        if not self.population:
            return
        
        self._dimension = len(self.population[0].representation)
        
        # Vectorized initialization
        self.velocities = np.random.uniform(-1, 1, (self.population_size, self._dimension))
        
        self.personal_bests = np.array([np.asarray(sol.representation) for sol in self.population])
        self.personal_best_fitness = np.array([sol.fitness for sol in self.population])
        
        self._update_global_best()

    def _update_global_best(self):
        """Update global best."""
        if self.personal_best_fitness is not None:
            best_idx = np.argmin(self.personal_best_fitness)
            if self.personal_best_fitness[best_idx] < self.global_best_fitness:
                self.global_best = self.personal_bests[best_idx].copy()
                self.global_best_fitness = self.personal_best_fitness[best_idx]
        
        if self.global_best is not None:
            self.best_solution = Solution(self.global_best.astype(int), self.problem)
            self.best_solution.fitness = self.global_best_fitness

    def step(self):
        """Vectorized PSO step."""
        self.ensure_population_evaluated()
        
        if self.velocities is None:
            self.initialize()
            return
        
        # Get current positions as matrix
        X = np.array([np.asarray(sol.representation, dtype=float) for sol in self.population])
        
        # Vectorized velocity update
        r1 = np.random.rand(self.population_size, self._dimension)
        r2 = np.random.rand(self.population_size, self._dimension)
        
        cognitive = self.c1 * r1 * (self.personal_bests - X)
        social = self.c2 * r2 * (self.global_best - X) if self.global_best is not None else 0
        
        self.velocities = self.omega * self.velocities + cognitive + social
        self.velocities = np.clip(self.velocities, -self.vmax, self.vmax)
        
        # Sigmoid and binary update - use steeper sigmoid for more deterministic behavior
        prob = 1.0 / (1.0 + np.exp(-2.0 * self.velocities))  # 2x steeper
        
        # More deterministic update - flip based on velocity direction
        # If velocity strongly points toward 1, set to 1; toward 0, set to 0
        new_X = X.copy().astype(int)
        flip_to_1 = prob > 0.7  # Strong signal for 1
        flip_to_0 = prob < 0.3  # Strong signal for 0
        uncertain = ~flip_to_1 & ~flip_to_0  # In between - use probability
        
        new_X[flip_to_1] = 1
        new_X[flip_to_0] = 0
        new_X[uncertain] = (np.random.rand(*uncertain.shape) < prob)[uncertain]
        
        # Create new solutions and evaluate
        new_population = []
        for i in range(self.population_size):
            sol = Solution(new_X[i], self.problem)
            new_population.append(sol)
        
        self.population = new_population
        self.ensure_population_evaluated()
        
        # Update personal bests
        for i in range(self.population_size):
            if self.population[i].fitness < self.personal_best_fitness[i]:
                self.personal_bests[i] = new_X[i].copy()
                self.personal_best_fitness[i] = self.population[i].fitness
        
        self._update_global_best()
        self.mark_best_dirty()
        self._update_best_solution()
        self.iteration += 1

    def ingest_population(self, seeds: List[Solution]):
        """Ingest population and re-initialize PSO state."""
        super().ingest_population(seeds)
        
        if not self.population:
            return
        
        self._dimension = len(self.population[0].representation)
        
        # Re-initialize with small velocities
        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self._dimension))
        
        self.personal_bests = np.array([np.asarray(sol.representation) for sol in self.population])
        self.personal_best_fitness = np.array([sol.fitness for sol in self.population])
        
        self.global_best_fitness = float('inf')
        self.global_best = None
        self._update_global_best()
